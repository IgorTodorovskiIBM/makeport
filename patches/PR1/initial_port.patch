diff --git a/Makefile.am b/Makefile.am
index 8cc39c9..ff8989e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -56,8 +56,10 @@ alloca_SRCS =	lib/alloca.c
 
 loadavg_SRCS =	lib/getloadavg.c
 
+zos_SRCS =	src/os390.c
+
 make_SOURCES =	$(make_SRCS)
-EXTRA_make_SOURCES = $(amiga_SRCS) $(vms_SRCS)
+EXTRA_make_SOURCES = $(amiga_SRCS) $(vms_SRCS) $(zos_SRCS)
 
 make_LDADD =	$(LIBOBJS) $(GUILE_LIBS) lib/libgnu.a $(GETLOADAVG_LIBS) \
 		@LIBINTL@
diff --git a/build.sh b/build.sh
index 4c88b53..5a19fb3 100755
--- a/build.sh
+++ b/build.sh
@@ -143,7 +143,9 @@ compile $OBJS
 
 # Link all the objects together.
 echo "linking make..."
-$CC $CFLAGS $LDFLAGS -L"$OUTLIB" $objs -lgnu $LOADLIBES -o "$OUTDIR/makenew$EXEEXT"
+set -x
+$CC $CFLAGS $LDFLAGS -L"$OUTLIB" -o "$OUTDIR/makenew$EXEEXT" $objs -lgnu $LOADLIBES
+set +x
 mv -f "$OUTDIR/makenew$EXEEXT" "$OUTDIR/make$EXEEXT"
 
 echo done.
diff --git a/src/arscan.c b/src/arscan.c
index 3ce21db..2a3e1f2 100644
--- a/src/arscan.c
+++ b/src/arscan.c
@@ -331,7 +331,7 @@ ar_scan (const char *archive, ar_member_func_t function, const void *varg)
 #endif
 
 #ifndef WINDOWS32
-# if !defined (__ANDROID__) && !defined (__BEOS__)
+# if !defined (__ANDROID__) && !defined (__BEOS__) && !defined(__MVS__)
 #  include <ar.h>
 # else
    /* These platforms don't have <ar.h> but have archives in the same format
@@ -426,6 +426,9 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
     char buf[SARMAG];
     int nread;
     nread = readbuf (desc, buf, SARMAG);
+#ifdef __MVS__
+    __e2a_s (buf);
+#endif
     if (nread != SARMAG || memcmp (buf, ARMAG, SARMAG))
       goto invalid;
   }
@@ -613,6 +616,9 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
 
 #else   /* Not AIAMAG.  */
         nread = readbuf (desc, &member_header, AR_HDR_SIZE);
+#ifdef __MVS__
+        __e2a_l ((char*) &member_header, sizeof (member_header));
+#endif
         if (nread == 0)
           /* No data left means end of file; that is OK.  */
           break;
diff --git a/src/job.c b/src/job.c
index ae1f18b..1a0088d 100644
--- a/src/job.c
+++ b/src/job.c
@@ -2298,7 +2298,14 @@ child_execute_job (struct childbase *child, int good_stdin, char **argv)
 
   pid = vfork();
   if (pid != 0)
+    {
+#ifdef __MVS__
+      zos_set_autocvt_on_untagged_fd_stream (fdin, 1047, 1);
+      zos_set_autocvt_on_untagged_fd_stream (fdout, 1047, 1);
+      zos_set_autocvt_on_untagged_fd_stream (fderr, 1047, 1);
+#endif
     return pid;
+    }
 
   /* We are the child.  */
   unblock_all_sigs ();
diff --git a/src/main.c b/src/main.c
index 78a27d7..44e65f4 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1050,10 +1050,21 @@ reset_jobserver (void)
 int
 main (int argc, char **argv)
 #else
+#ifdef __MVS__
+extern char **environ;
+int 
+main (int argc, char **argv)
+#else
 int
 main (int argc, char **argv, char **envp)
 #endif
+#endif
 {
+#ifdef __MVS__
+  char** envp = environ;
+  zos_init();
+#endif
+
   static char *stdin_nm = 0;
   int makefile_status = MAKE_SUCCESS;
   struct goaldep *read_files;
@@ -1072,6 +1083,12 @@ main (int argc, char **argv, char **envp)
   no_default_sh_exe = 1;
 #endif
 
+#ifdef __MVS__
+  zos_set_autocvt_on_untagged_fd_stream (STDIN_FILENO, 1047, 1);
+  zos_set_autocvt_on_untagged_fd_stream (STDOUT_FILENO, 1047, 1);
+  zos_set_autocvt_on_untagged_fd_stream (STDERR_FILENO, 1047, 1);
+#endif
+
   /* Useful for attaching debuggers, etc.  */
   SPIN ("main-entry");
 
diff --git a/src/makeint.h b/src/makeint.h
index c428a36..079dc8e 100644
--- a/src/makeint.h
+++ b/src/makeint.h
@@ -26,6 +26,11 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #define _GNU_SOURCE 1
 
+#ifdef __MVS__
+/* Required to override C functions pipe, open */
+# include "os390.h"
+#endif
+
 /* AIX requires this to be the first thing in the file.  */
 #if HAVE_ALLOCA_H
 # include <alloca.h>
diff --git a/src/misc.c b/src/misc.c
index de19e37..c720778 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -508,7 +508,7 @@ get_tmpfile (char **name, const char *template)
   (void) tmpnam (*name);
 # endif
 
-# ifdef HAVE_FDOPEN
+# if defined(HAVE_FDOPEN)
   /* Can't use mkstemp(), but guard against a race condition.  */
   EINTRLOOP (fd, open (*name, O_CREAT|O_EXCL|O_WRONLY, 0600));
   if (fd == -1)
@@ -522,6 +522,10 @@ get_tmpfile (char **name, const char *template)
 
   umask (mask);
 
+#if defined(__MVS__)
+  zos_chgfdccsid (fileno (file), 819);
+#endif
+
   return file;
 }
 
diff --git a/src/os390.c b/src/os390.c
new file mode 100644
index 0000000..3327874
--- /dev/null
+++ b/src/os390.c
@@ -0,0 +1,162 @@
+#ifdef __MVS__
+#include "config.h"
+
+#include <string.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ps.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <varargs.h>
+#include <limits.h>
+#include <_Nascii.h>
+#include <fcntl.h>
+#include <libgen.h>
+
+int
+zos_setccsid (int fd, int ccsid)
+{
+  attrib_t attr;
+  int rc;
+
+  memset (&attr, 0, sizeof (attr));
+  attr.att_filetagchg = 1;
+  attr.att_filetag.ft_ccsid = ccsid;
+  attr.att_filetag.ft_txtflag = 1;
+
+  rc = zos_fchattr (fd, &attr, sizeof (attr));
+  return rc;
+}
+
+void
+zos_updateccsid (int fd, const char* path, int oflag, 
+                int perm)
+{
+  int rc;
+  if (oflag & O_CREAT)
+    rc = zos_setccsid (fd, 819);
+}
+
+int
+zos_pipe (int [2]);
+#pragma map(zos_pipe, "pipe")
+int
+zos_open (const char *filename, int opts, ...);
+#pragma map(zos_open, "@@A00144")
+
+int
+zos_open_ascii (const char *filename, int opts, ...)
+{
+  va_list ap;
+  va_start (ap, opts);
+  int perms = va_arg (ap, int);
+  struct stat sb;
+  int is_new_file = stat (filename, &sb) != 0;
+  int fd = zos_open (filename, opts, perms);
+  // Tag new files as 819
+  if (fd >= 0 && is_new_file)
+    zos_chgfdccsid (fd, 819);
+  va_end (ap);
+  return fd;
+}
+
+int
+zos_pipe_ascii(int fd[2])
+{
+  int ret = zos_pipe (fd);
+
+  // Default ccsid for new pipes should be 819
+  zos_chgfdccsid (fd[0], 819);
+  zos_chgfdccsid (fd[1], 819);
+  return ret;
+}
+
+int
+zos_getfdccsid(int fd)
+{
+  struct stat st;
+  int rc;
+  rc = fstat (fd, &st);
+  if (rc != 0)
+    return -1;
+  unsigned short ccsid = st.st_tag.ft_ccsid;
+  if (st.st_tag.ft_txtflag)
+    return 65536 + ccsid;
+  return ccsid;
+}
+
+int
+zos_chgfdccsid(int fd, unsigned short ccsid)
+{
+  attrib_t attr;
+  memset(&attr, 0, sizeof(attr));
+  attr.att_filetagchg = 1;
+  attr.att_filetag.ft_ccsid = ccsid;
+  if (ccsid != FT_BINARY)
+    attr.att_filetag.ft_txtflag = 1;
+  return zos_fchattr (fd, &attr, sizeof(attr));
+}
+
+void
+zos_set_autocvt_on_untagged_fd_stream (int fd, unsigned short ccsid, 
+                                       unsigned char txtflag)
+{
+  struct file_tag tag;
+
+  tag.ft_ccsid = ccsid;
+  tag.ft_txtflag = txtflag;
+
+  struct f_cnvrt req = {SETCVTON, 0, (short)ccsid};
+
+  if (!isatty (fd) && 0 == zos_getfdccsid (fd))
+    {
+      fcntl (fd, F_CONTROL_CVT, &req);
+      fcntl (fd, F_SETTAG, &tag);
+    }
+}
+
+int orig_mode;
+int orig_cvstate;
+
+void 
+zos_init ()
+{
+    // With "_EDC_SIG_DFLT" set to '0', a process closing with SIGINT send output both to stderr and stdout. 
+    // Setting "_EDC_SIG_DFLT" default action of the following signals is abnormal termination of the process with no message output: SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGPOLL, SIGPROF, SIGSYS, SIGTERM, SIGUSR1, SIGUSR2, and SIGVTALRM
+    setenv ("_EDC_SIG_DFLT", "1", 1);
+
+    // Setting _EDC_SUSV3 can be used to control the behavior of setenv() with respect to setting EINVAL when var_name is a null pointer, points to an empty string or points to a string containing an '=' character. By default, setenv() will not set EINVAL for these conditions. 
+    // When _EDC_SUSV3 is set to 1, setenv() will set errno to EINVAL if one of these conditions is true. 
+    setenv ("_EDC_SUSV3", "1", 1);
+
+    // Sets the _TAG_REDIR state to txt
+    setenv ("_TAG_REDIR_ERR", "txt", 1);
+    setenv ("_TAG_REDIR_IN", "txt", 1);
+    setenv ("_TAG_REDIR_OUT", "txt", 1);
+
+    // Force to ASCII mode and AUTOCVT to ON
+#if (zos_CHARSET_LIB == 1)
+    orig_mode = zos_ae_thread_swapmode (__AE_ASCII_MODE);
+#else
+    orig_mode = zos_ae_thread_swapmode (__AE_EBCDIC_MODE);
+#endif
+    orig_cvstate = zos_ae_autoconvert_state (_CVTSTATE_QUERY);
+    if (_CVTSTATE_OFF == orig_cvstate)
+      zos_ae_autoconvert_state (_CVTSTATE_ON);
+
+    setenv ("_BPXK_AUTOCVT", "ON", 1);
+    char* cee_runopts_env = getenv ("_CEE_RUNOPTS");
+    char* appended_cee_runopts = "FILETAG(AUTOCVT,AUTOTAG) POSIX(ON)";
+    char* new_cee_runopts = (char*)malloc (strlen (cee_runopts_env) + strlen (appended_cee_runopts) + 2);
+    memset (new_cee_runopts, 0, strlen (cee_runopts_env) + strlen (appended_cee_runopts) + 2);
+    if (cee_runopts_env)
+      {
+        strcpy(new_cee_runopts, cee_runopts_env);
+        strcat (new_cee_runopts, " ");
+      }
+    strcat (new_cee_runopts, appended_cee_runopts);
+    setenv ("_CEE_RUNOPTS", new_cee_runopts, 1);
+    free (new_cee_runopts);
+}
+#endif
diff --git a/src/os390.h b/src/os390.h
new file mode 100644
index 0000000..28eb0a3
--- /dev/null
+++ b/src/os390.h
@@ -0,0 +1,34 @@
+#ifndef H_OS390
+#define H_OS390 1
+
+#if (__CHARSET_LIB == 1)
+#undef open
+#define open __open_replaced
+#undef pipe 
+#define pipe __pipe_replaced
+#include <fcntl.h>
+#include <unistd.h>
+#undef pipe
+#undef open
+
+int zos_open_ascii(const char *filename, int opts, ...);
+int zos_pipe_ascii(int [2]);
+
+int open(const char* path, int oflag, ...) asm("zos_open_ascii");
+int pipe(int [2]) asm("zos_open_ascii");
+#endif
+
+#include <string.h>
+#include <sys/ps.h>
+#include <unistd.h>
+#include <limits.h>
+#include <_Nascii.h>
+#include <fcntl.h>
+#include <libgen.h>
+
+int zos_getfdccsid(int fd);
+int zos_setccsid(int fd, int ccsid);
+int zos_chgfdccsid(int fd, unsigned short ccsid);
+void zos_updateccsid(int fd, const char* path, int oflag, int perm);
+
+#endif
diff --git a/src/output.c b/src/output.c
index 2211749..b7d5424 100644
--- a/src/output.c
+++ b/src/output.c
@@ -250,6 +250,7 @@ pump_from_tmp (int from, FILE *to)
 #endif
 }
 
+#ifdef __MVS__
 /* Obtain the lock for writing output.  */
 static void *
 acquire_semaphore (void)
@@ -275,6 +276,33 @@ release_semaphore (void *sem)
   if (fcntl (sync_handle, F_SETLKW, flp) == -1)
     perror ("fcntl()");
 }
+#else
+/* Obtain the lock for writing output.  */
+static void *
+acquire_semaphore (void)
+{
+  static struct flock fl;
+
+  fl.l_type = F_WRLCK;
+  fl.l_whence = SEEK_SET;
+  fl.l_start = 0;
+  fl.l_len = 1;
+  if (fcntl (sync_handle, F_SETLKW, &fl) != -1)
+    return &fl;
+  perror ("fcntl()");
+  return NULL;
+}
+
+/* Release the lock for writing output.  */
+static void
+release_semaphore (void *sem)
+{
+  struct flock *flp = (struct flock *)sem;
+  flp->l_type = F_UNLCK;
+  if (fcntl (sync_handle, F_SETLKW, flp) == -1)
+    perror ("fcntl()");
+}
+#endif
 
 /* Returns a file descriptor to a temporary file.  The file is automatically
    closed/deleted on exit.  Don't use a FILE* stream.  */
diff --git a/src/posixos.c b/src/posixos.c
index 525f292..73e480d 100644
--- a/src/posixos.c
+++ b/src/posixos.c
@@ -37,7 +37,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* This section provides OS-specific functions to support the jobserver.  */
 
 /* These track the state of the jobserver pipe.  Passed to child instances.  */
-static int job_fds[2] = { -1, -1 };
+static int job_fds[2] = {-1, -1};
 
 /* Used to signal read() that a SIGCHLD happened.  Always CLOEXEC.
    If we use pselect() this will never be created and always -1.
diff --git a/tests/test_driver.pl b/tests/test_driver.pl
index f18e785..46544a5 100644
--- a/tests/test_driver.pl
+++ b/tests/test_driver.pl
@@ -164,6 +164,10 @@ sub toplevel
   foreach (# UNIX-specific things
            'TZ', 'TMPDIR', 'HOME', 'USER', 'LOGNAME', 'PATH',
            'LD_LIBRARY_PATH',
+           # z/OS specific things
+           'LIBPATH',
+           '_BPXK_AUTOCVT',
+           '_TAG_REDIR_IN', '_TAG_REDIR_ERR', '_TAG_REDIR_OUT',
            # SAN things
            'ASAN_OPTIONS', 'UBSAN_OPTIONS',
            # Purify things
@@ -392,15 +396,17 @@ sub get_osname
     # to not get ugly error messages if uname can't be found.
     # Hmmm, BSD/OS 2.0's uname -a is excessively verbose.  Let's try it
     # with switches first.
-    eval "chop (\$osname = `sh -c 'uname -nmsr 2>&1'`)";
-    if ($osname =~ /not found/i) {
-      $osname = "(something posixy with no uname)";
-
-    } elsif ($@ ne "" || $?) {
-      eval "chop (\$osname = `sh -c 'uname -a 2>&1'`)";
-      if ($@ ne "" || $?) {
-        $osname = "(something posixy)";
-      }
+    if ($osname eq "") {
+      eval "chop (\$osname = `uname -nmsr 2>&1`)";
+      if ($osname =~ /not found/i) {
+        $osname = "(something posixy with no uname)";
+
+      } elsif ($@ ne "" || $?) {
+        eval "chop (\$osname = `uname -a 2>&1`)";
+        if ($@ ne "" || $?) {
+          $osname = "(something posixy)";
+        }
+     }
     }
     $vos = 0;
     $pathsep = "/";
